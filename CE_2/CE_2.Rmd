---
title: 'Advanced Time Series Analysis: Computer Exercise 2'
author: "Anders Launer Bæk (s160159)"
date: "`r format(Sys.time(), '%d %B %Y')`"
header-includes: 
    - \usepackage{graphicx}
output:
  pdf_document: default
---

```{r setup, include=FALSE}
rm(list = ls())

knitr::opts_chunk$set(echo = FALSE, 
                      include = TRUE,
                      warning = FALSE,
                      fig.width = 8, fig.height = 4,
                      fig.show='hold', fig.align='center',
                      
                      eval = TRUE, 
                      tidy = TRUE, 
                      dev = 'pdf', 
                      cache = TRUE, fig.pos = "th!")

kable_format <- list(small.mark = ",",
                     big.mark = ',',
                     decimal.mark = '.',
                     nsmall = 3,
                     digits = 3,
                     scientific = FALSE,
                     big.interval = 3L)

library(ggplot2)
theme_TS <- function(base_size = 9, base_family = "", face = "plain"){
  theme_bw(base_size = base_size, base_family = base_family) %+replace%
    theme(panel.background = element_blank(), 
          panel.border = element_blank(),
          panel.grid = element_blank(),
          axis.text = element_text(size = base_size, face = face, family = base_family),
          axis.title = element_text(size = base_size, face = face, family = base_family),
          legend.text = element_text(size = base_size, face = face, family = base_family))
}

```
Sparring partners:
\begin{itemize}
\item Anja Liljedahl Christensen (s162876)
\item Marie Mørk (s112770)
\end{itemize}

## Part 1
There are simulated $n=3000$ where $\epsilon_t \sim \mathcal{N}(0,\,1)$. $\epsilon_t$ is used as noise input for all simulations in part one.

```{r}
## Number of samplepoints
n <- 3000
load(file = "~/DTU/Courses/Advanced Time Series/Projects/noise.Rda")

data <- data.frame(t = 1:n, noise = r[1:n])

# define parameter for SETAR
a0 <- c(0.125, -0.125) # off set
a1 <- c(0.6, -0.4) # slope

```

The equation below shows the used parameters in the SETAR(2,1,1). Let us call eq. \ref{eq_1_2a} and eq. \ref{eq_1_2b} parameter set one ($par_1$).

\begin{equation}
a_0 = [`r a0[1]`, `r a0[2]`]
\label{eq_1_2a}
\end{equation}
\begin{equation}
a_1 = [`r a1[1]`, `r a1[2]`]
\label{eq_1_2b}
\end{equation}

 
### Simulation of the SETAR(2,1,1)

The Self-Exciting Threshold AR (SETAR) model is given by eq. \ref{eq_1_SETAR}.

\begin{equation}
X_t = a_0^{(J_t)} + \sum_{i = 1}^{k_{(J_t)}} a_i^{(J_t)} X_{t-i}+\epsilon^{(J_t)}
\label{eq_1_SETAR}
\end{equation}
where $J_t$ are regime processes. The complete model are defined in eq. \ref{eq_1_SETAR_r}.

\begin{equation}
X_t = \left\{ \begin{matrix} a_{0,1} + a_{1,1} X_{t- 1} + \epsilon_t & for & X_{t-1} \leq0 \\  a_{0,2} + a_{1,2} X_{t- 1} + \epsilon_t &  for & X_{t-1} >0 \end{matrix} \right\}
\label{eq_1_SETAR_r}
\end{equation}

The model $X_t$ (eq. \ref{eq_1_SETAR_r}) has been simulated with $par_1$. Its simulation is plotted in fig. \ref{fig_ex_2}. 

```{r, fig.cap="\\label{fig_ex_1}Two simulated SETAR(2,1,1) models using $par_1$ and $par_2$."}
## Make a time series y with a regime model
data$y_SETAR <- rep(NA,n)
data$y_SETAR[1] <- data$noise[1]

for(t in 2:n) {
  if(data$y_SETAR[t - 1] <= 0) {
    data$y_SETAR[t] <- a0[1] + a1[1] * data$y_SETAR[t-1] + data$noise[t]
  } else {
    data$y_SETAR[t] <- a0[2] + a1[2] * data$y_SETAR[t-1] + data$noise[t]
  }
}

#
data$y_SETAR_1 <- rep(NA, n)
data$y_SETAR_1[2:n] <- data$y_SETAR[1:(n-1)]


data$mean_theo <- rep(NA, n)

# plot data
ggplot(data) +
  geom_point(aes(x = y_SETAR_1, y = y_SETAR, color = "SETAR(2,1,1)"), alpha = 1/2) +
  #ylim(0, 1) +
  labs(x = "y(t - 1)", y = "y(t)", color = "") +
  theme_TS()
```

### Estimate the parameters using conditional least squares

```{r, echo=TRUE}

Setar <- function(par, model) {
  #
  e_mean <- rep(NA, length(model))
  #
  for(t in 2:length(model)) {
    if(model[t - 1 ] <= 0) {
      e_mean[t] <- par[1] + par[2] * model[t - 1]
      } else {
        e_mean[t] <- par[3] + par[4] * model[t - 1]
      }
    }
  #
  return(e_mean)
}


RSSSetar <- function(par, model) {
  # conditional mean
  e_mean <- Setar(par, model)
  
  ## Calculate and return the residuals
  return((model - e_mean)^2)
}


PESetar <- function(par, model) {
  # conditional mean
  e_mean <- Setar(par, model)
  
  ## Calculate and return the objective function value
  return(sum((model - e_mean)^2, na.rm = TRUE))
}
```


```{r}


optimal_PE <- optim(par = c(a0[1],a1[1],a0[2],a1[2]), fn = PESetar, model = data$y_SETAR)

data$y_SETAR_opti <- Setar(par = optimal_PE$par, model = data$y_SETAR)

data$y_SETAR_mean <- Setar(par = c(a0[1],a1[1],a0[2],a1[2]), model = data$y_SETAR)

data$rsssetar <- RSSSetar(par = optimal_PE$par, model = data$y_SETAR)




# plot data
ggplot(data) +
  geom_point(aes(x = y_SETAR_1, y = y_SETAR, color = "SETAR(2,1,1)"), alpha = 1/2) +
  geom_line(aes(x = y_SETAR_1, y = y_SETAR_mean, color = "M(x) theo."), alpha = 1/2) +
  geom_line(aes(x = y_SETAR_1, y = y_SETAR_opti, color = "M(x) optim()"), alpha = 1/2) +
  #ylim(0, 1) +
  labs(x = "y(t - 1)", y = "y(t)", color = "") +
  theme_TS()
```


Den lodrette linje findes selfølgelig ikke!!

comment !!!



## Part 2
```{r}
max_change_p <- 0.1
resolution <- 50
```


resolution `r resolution`
max_change_p `r max_change_p`

only change the slope par[2] and par [4]

```{r}
# only change the slope par[2] and par [4]
plot_contours <- function(model, par = optimal_PE$par, change_p = 0.1, nplot = 50){ 
  #
  par_2_seq <- seq(par[2] - par[2] * change_p, par[2] + par[2] * change_p, len = nplot)
  par_4_seq <- seq(par[4] - par[4] * change_p, par[4] + par[4] * change_p, len = nplot)
  
  loess <- outer(par_2_seq, par_4_seq, function(par_2, par_4) {
  L <- lapply(1:length(par_2), function(i) {
    
    return(PESetar(par = c(par[1], par_2[i], par[3], par_4[i]), model))
    })
  return(do.call("rbind",L))
  })
  
  loess_melt <- reshape2::melt(loess)
  loess_melt$Var1 <- par_2_seq[loess_melt$Var1]
  loess_melt$Var2 <- par_4_seq[loess_melt$Var2]

  return(ggplot(loess_melt, aes(x = Var1, y = Var2, z = value)) +
    stat_contour(geom="polygon", aes(fill=..level..)) +
    #scale_fill_gradient(low = "red", high = "blue") +
      geom_point(aes(x = par[2], y =par[4] , color = "optim par_2,4"), alpha = 1/2) +
    labs(x = "par[2]", y = "par[4]", color = "par_i") +
    theme_TS())
}
```


### N = 1:3000
```{r, fig.cap="\\label{fig_ex_8_1}Contour plot of the conditional parametric model approach."}
N = 1:3000
plot_contours(model = data$y_SETAR[N], par = optimal_PE$par, change_p = max_change_p, nplot = resolution)
```


\ref{fig_ex_8_1}

### N = 1:300
```{r}
N = 1:300
plot_contours(model = data$y_SETAR[N], par = optimal_PE$par, change_p = max_change_p, nplot = resolution)
```

### N = 1:30
```{r}
N = 1:30
plot_contours(model = data$y_SETAR[N], par = optimal_PE$par, change_p = max_change_p, nplot = resolution)
```


### N = 1001:1300
```{r}
N = 1001:1300
plot_contours(model = data$y_SETAR[N], par = optimal_PE$par, change_p = max_change_p, nplot = resolution)
```

### N = 1001:1030
```{r}
N = 1001:1030
plot_contours(model = data$y_SETAR[N], par = optimal_PE$par, change_p = max_change_p, nplot = resolution)
```



### Discuss my findings


## Part 3

I consider following non-linear doubly stochastic model, eq. \ref{eq_3_1}.

\begin{equation}
\begin{align}

\end{align}
\label{eq_3_1}
\end{equation}

Tænk hvor havd der sker i den underlæggende proces ?

hvordan er stationary conditions?




### Simulate 

```{r}
nn = 500
data_3 <- subset(data, subset = 1:n %in% 1:nn, select = c("t"))
n <- nrow(data_3)
data_3$Y <- rep(NA, n)
data_3$Phi <- rep(NA, n)

mu <- 0.1
sigma_2_zeta <- 0.10^2
sigma_2_epsilon <- 4.0^2

data_3$zeta <- rnorm(n, mean = mu, sd = sqrt(sigma_2_zeta))
data_3$epsilon <- rnorm(n, mean = mu, sd = sqrt(sigma_2_epsilon))


cov(data_3$zeta,data_3$epsilon)

# init
data_3$Y[1] <- data_3$epsilon[1]

data_3$Phi[1] <- data_3$zeta[1]
phi <- 0.85
delta <- mu * (1 - phi)

# underlying
A <- matrix(data = c(phi,0,1,1), nrow = 2, ncol = 2)
X <- matrix(data = c(data_3$Phi[1], delta), nrow = 2)
ZETA <- matrix(data = c(1,0), nrow = 2)

for (i in 2:n) {
  # underlying   
  X <- A %*% X + ZETA * data_3$zeta[i]  
  # capture Phi
  data_3$Phi[i] <- X[1]
  # overlying   
  data_3$Y[i] <- matrix(data = c(data_3$Y[i - 1], 0), ncol = 2) %*% X + data_3$epsilon[i]  
  
}

ggplot(data_3) +
  geom_line(aes(x = t, y = Y, color = "Y(t)"), alpha = 1/2) +
  labs(x = "t", y = "Y(t)", color = "") +
  theme_TS()
```


```{r}
ggplot(data_3) +
  geom_line(aes(x = t, y = Phi, color = "Phi(t)"), alpha = 1/2) +
  labs(x = "t", y = "Y(t)", color = "") +
  theme_TS()
```




### Comment


