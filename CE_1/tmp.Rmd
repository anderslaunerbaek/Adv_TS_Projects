## IGAR(2,1)
```{r, fig.cap=fig$cap("ex_3", "")}
## Make a time series y with a regime model
y_IGAR <- rep(NA,n)
y_IGAR[1] <- data$noise[1]

# simulate probability for regime shift
data$p <- runif(n)
for(t in 2:n) {
  #
  if(data$p[t] <= 0.50) {
    y_IGAR[t] <- a0[1] + a1[1] * y_IGAR[t - 1] + data$noise[t]
  } else {
    y_IGAR[t] <- a0[2] + a1[2] * y_IGAR[t - 1] + data$noise[t]
  }
}

# 
data$y_IGAR <- y_IGAR
data$y_IGAR_1 <- rep(NA, n)
data$y_IGAR_1[2:n] <- data$y_IGAR[1:(n-1)]

# plot data
ggplot(data) +
  #geom_point(aes(x = t, y = x, color = "Data"), alpha = 1/2) +
  geom_point(aes(x = y_IGAR_1, y = y_IGAR, color = "IGAR(2,1)"), alpha = 1/2) +
  #ylim(0, 1) +
  labs(x = "y(t - 1)", y = "y(t)", color = "") + 
  theme_TS()

```



## MMAR(2,1)
```{r, fig.cap=fig$cap("ex_4", "")}
# transition parameters
P <- matrix(data = c(0.95,0.05, 0.05,0.95), nrow = 2, ncol = 2)

# there are two regimes
jt <- rep(NA,n)

# init first t in stage 1
jt[1] <- 1

for (t in 2:n) {
  data$p[t] <- runif(1)
  if (jt[t - 1] == 1) {
    # jt - 1 is 2
    if (p[t] <= P[1,1]) {
      # first regime
      jt[t] <- 1
      } else { jt[t] <- 2 }
  } else {
    # jt - 1 is 2 
    if (p[t] <= P[2,2]) {
       # first regime
       jt[t] <- 2
       } else { jt[t] <- 1 }
  }
}

data$jt <- jt



## Make a time series y with a regime model
y_MMAR <- rep(NA,n)
y_MMAR[1] <- data$noise[1]
for(t in 2:n) {
  if(data$jt[t - 1] == 1) {
    y_MMAR[t] <- a0[1] + a1[1] * y_MMAR[t - 1] + data$noise[t]
  } else {
    y_MMAR[t] <- a0[2] + a1[2] * y_MMAR[t - 1] + data$noise[t]
  }
}

# 
data$y_MMAR <- y_MMAR

data$y_MMAR_1 <- rep(NA, n)
data$y_MMAR_1[2:n] <- data$y_MMAR[1:(n-1)]

# plot data
ggplot(data) +
  #geom_point(aes(x = t, y = x, color = "Data"), alpha = 1/2) +
  #geom_line(aes(x = t, y = x, color = "Data"), alpha = 1/2) +
  geom_point(aes(x = y_MMAR_1, y = y_MMAR, color = "MMAR(2,1)"), alpha = 1/2) +
  #ylim(0, 1) +
  labs(x = "y(t - 1)", y = "y(t)", color = "") + 
  theme_TS()

```







```{r}


```






























```{r tab.cap=tab$cap("ex_1", "Here you see some interesting stuff about cars and such.")}

knitr::kable(head(data, 5))


```
 
figure `r tab$ref("ex_1")`






# Part 2

Using the SETAR model from part 1

## SETAR(2,1,1)
```{r, fig.cap=fig$cap("ex_5", "")}
## Make a time series y with a regime model
data$mean_theo <- rep(NA,n)
data$mean_theo[1] <- 0
for(t in 2:n) {
  if(data$y_SETAR[t - 1 ] <= 0) {
    data$mean_theo[t] <- a0[1] + a1[1] * data$y_SETAR[t - 1]
  } else {
    data$mean_theo[t] <- a0[2] + a1[2] * data$y_SETAR[t - 1]
  }
}

#
ggplot(data) +
  geom_point(aes(x = y_SETAR_1, y = y_SETAR, color = "s(2,1,1)"), alpha = 1/2) +
  geom_line(aes(x = y_SETAR_1, y = mean_theo, color = "mean(2,1,1)"), alpha = 1/2) +
  labs(x = "y(t - 1)", y = "y(t)", color = "") +
  theme_TS()

```


adasd 

```{r, fig.cap=fig$cap("ex_6", "")}
#
data$mean_pred_fit <- rep(NA, n)
bandwidth <- 0.1
#
data$mean_pred_fit[2:n] <- loess(y_SETAR ~ y_SETAR_1, 
                                 dat = data[2:n, ], 
                                 span = bandwidth)$fitted



# data$mean_pred_fit[2:n] <- lm(y_SETAR ~ y_SETAR_1, 
#                                  dat = data[2:n, ], 
#                                  span = bandwidth)$fitted

#
ggplot(data) +
  geom_point(aes(x = y_SETAR_1, y = y_SETAR, color = "SETAR(2,1,1)"), alpha = 1/2) +
  geom_line(aes(x = y_SETAR_1, y = mean_pred_fit, color = "mean_hat(2,1,1)"), alpha = 1/2) +
  labs(x = "y(t - 1)", y = "y(t)", color = "") + 
  theme_TS()
```
comment on the bandwith


use KNN to get better boundaries points

# Part 3


```{r, fig.cap=fig$cap("ex_7", "")}

## Parameters for the histogram regression
## Number of intervals 
n.bin <- 100
## The breaks between the intervals 
breaks <- seq(min(data$y_SETAR_1, na.rm = TRUE), 
              max(data$y_SETAR_1, na.rm = TRUE), 
              len = n.bin + 1)
# ## Initialize
# h <- diff(breaks)[1]
# lambda <- gamma <- f.hat <- h.hat <- numeric(n.bin)
##----------------------------------------------------------------
## Cut into intervals conditioned on x_{t-1}
L <- split(data$y_SETAR, cut(data$y_SETAR_1, breaks))
## Check if there are at least 5 points in each interval
# if (!all(sapply(L, length) >= 5)){ 
#   print('Stopped: There are less than 5 points in one of the intervals')
#   break
# }
while(!all(sapply(L, length) >= 5)) {
  #
  n.bin <- n.bin - 1
  ## The breaks between the intervals 
  breaks <- seq(min(data$y_SETAR_1, na.rm = TRUE), max(data$y_SETAR_1, na.rm = TRUE), len = n.bin + 1)
  ## Cut into intervals conditioned on x_{t-1}
  L <- split(data$y_SETAR, cut(data$y_SETAR_1, breaks))
}

## Initialize
h <- diff(breaks)[1]
lambda <- gamma <- f.hat <- h.hat <- numeric(n.bin)


## Calc the hist regressogram, i.e. for each interval
for(i in 1:n.bin) {
    x.bin <- L[[i]]
    lambda[i] <- mean(x.bin)
    f.hat[i] <- (n.bin * h)^(-1) * length(x.bin)
    gamma[i] <- sum((x.bin - lambda[i])^2) / length(x.bin)
  }
# ## Make confidence bands for the cumulated function. Def. (3.10).
# ## 95% confidence band, c is found in table 3.1
# c.alpha <- 1.273
# ##
Lambda <- cumsum(lambda * h)
# for (i in 1:n.bin) {
#   h.hat[i] <- gamma[i]/f.hat[i];
# }
# H.hat <- cumsum(h.hat*h);
# ##


# H.hat.b <- H.hat[n.bin];
# Lambda.lower <- Lambda - c.alpha * n.bin^(-0.5) * H.hat.b^(0.5) * (1 + H.hat/H.hat.b);
# Lambda.upper <- Lambda + c.alpha * n.bin^(-0.5) * H.hat.b^(0.5) * (1 + H.hat/H.hat.b);


#
confi <- data.frame(breaks = (breaks + h/2)[-length(breaks)], 
                    #lower = Lambda.lower, 
                    #upper = Lambda.upper,
                    cum_con_mean = Lambda) 


# #
ggplot(data) +
  geom_point(aes(x = y_SETAR_1, y = y_SETAR, color = "SETAR(2,1,1)"), alpha = 1/2) +
  geom_line(aes(x = y_SETAR_1, y = mean_theo, color = "mean_theo(2,1,1)"), alpha = 1/2) +
  labs(x = "y(t - 1)", y = "y(t)", color = "") +
  theme_TS() +
  #geom_line(data = confi, aes(x = breaks, y = upper, color = "upper CI"), alpha = 1/2) +
  #geom_line(data = confi, aes(x = breaks, y = lower, color = "lower CI"), alpha = 1/2) +
  geom_point(data = confi, aes(x = breaks, y = cum_con_mean, color = "mean_cum_con CI"), alpha = 1)
```
and compare with the theoretical cumulative conditional mean.

# Part 4

describe the function

```{r, fig.cap=fig$cap("ex_8", "")}
## Number of samplepoints
n <- 3000
## Uniform distributed x
x <- runif(n,-1,1)
## Errors
r <- rnorm(n) / 10
data_4 <- data.frame(t = 1:n, x = x, noise = r, y = rep(NA, n))

data_4$x_1 <- rep(NA, n)
data_4$x_1[2:n] <- data_4$x[1:(n-1)]

# define continuously differentiable function
g <- function(x) {
  #
  return(1 / (1 + exp(-x))) 
  #return(x * x) 
}
#
data_4$y[1] <- mu <- data_4$noise[1]
#
for (t in 2:n) {
  #
  data_4$y[t] <- mu + g(data_4$x[t - 1]) * data_4$y[t - 1] + data_4$noise[t]
}
#
data_4$y_1 <- rep(NA, n)
data_4$y_1[2:n] <- data_4$y[1:(n-1)]

# ggplot(data_4) +
#   geom_line(aes(x = y_1, y = y, color = "y"), alpha = 1/2) +
#   labs(x = "y(t - 1)", y = "y(t)", color = "") +
#   theme_TS()
```
Use these simulated valuues to estimate the dependence of yt on xt 1 and yt 1 using the method of local regression. below 
```{r, fig.cap=fig$cap("ex_9", "")}

##------------------------------------------------
## Estimate the function with local polynomial regression using lm()
## It is possible to use different bandwidths in each dimension.

data_4 <- data_4[-1, ]


## Epanechnikov kernel
kernelEp <- function(xall, x, h) {
  ## Make the weights with an Epanechnikov kernel
  ## h has the same unit as x (i.e. it is on the same absolute scale, so if x is Watt, h is also given in Watt) 
  u <- abs(xall - x)
  u <- u / h
  w <- 3/4 * (1 - u^2)
  ## Set values with |u|>1 to 0
  w[abs(u) > 1] <- 0
  return(w)
}

## Bandwidths in each two-dimensional multiplicative kernel relative to the range of x and y
bandwidth <- 0.3 
hx <- bandwidth * (max(data_4$x_1, na.rm = TRUE) - min(data_4$x_1, na.rm = TRUE))
hy <- bandwidth * (max(data_4$y_1, na.rm = TRUE) - min(data_4$y_1, na.rm = TRUE))


nplot <- 100
x1Seq <- seq(min(data_4$x), max(data_4$x), len = nplot)
y1Seq <- seq(min(data_4$y), max(data_4$y), len = nplot)

open3d() ## Note: Do not use rgl.open()
points3d(data_4$x_1, data_4$y_1, data_4$y, size=3, col="red")
aspect3d(c(1,1,1))
axes3d()
title3d(xlab = "x[t-1]", ylab = "y[t-1]", zlab = "y[t]")


## Do local 1'st order regression. This can also easily be changed to a conditional parametric model
yprd <- outer(x1Seq, y1Seq, function(x1,y1) {
  L <- lapply(1:length(x1), function(i) {
    ## Just a tip for debugging in R: Use browser() to stop inside some function. Quit with "Q", see ?browser
    ##browser()
    ## Calculate the weights in each dimension
    wx <- kernelEp(data_4$x_1, x1[i], h = hx)
    wy <- kernelEp(data_4$y_1, y1[i], h = hy)
    w <- wx * wy
    ## Do it only with positive weights
    ok <- w > 0
    ## Note that this is local first order polynomial regression, but can easily be made 2'nd
    fit <- lm(y ~ x_1 + y_1, weights=w[ok], dat=data_4[ok,])
    return(predict(fit, data.frame(x_1=x1[i], y_1=y1[i])))
  })
  return(do.call("rbind",L))
})
## Draw the surface. See ?rgl.material for options
surface3d(x1Seq, y1Seq, yprd, color="blue", alpha=0.5)


# ggplot(data_4) +
#   geom_line(aes(x = y_1, y = y, color = "y"), alpha = 1/2) +
#   labs(x = "y(t - 1)", y = "y(t)", color = "") +
#   theme_TS()
```
```{r, fig.cap=fig$cap("ex_10", "")}

```

# Part 5
```{r, fig.cap=fig$cap("ex_11", "")}
## Make a time series y with a regime model
data_5 <- subset(data, select = c("t", "x", "noise"))
n <- nrow(data_5)




a0 <- c(2.0, -1.0) # off set
a1 <- c(0.6, -0.4)

data_5$y_SETAR <- rep(NA,n)
data_5$mean_theo <- rep(NA,n)
data_5$y_SETAR[1] <- data_5$noise[1]
for(t in 2:n) {
  if(data_5$y_SETAR[t - 1] <= 0) {
    data_5$y_SETAR[t] <- a0[1] + a1[1] * data_5$y_SETAR[t-1] + data_5$noise[t]
    data_5$mean_theo[t] <- a0[1] + a1[1] * data_5$y_SETAR[t - 1]
  } else {
    data_5$y_SETAR[t] <- a0[2] + a1[2] * data_5$y_SETAR[t-1] + data_5$noise[t]
    data_5$mean_theo[t] <- a0[2] + a1[2] * data_5$y_SETAR[t - 1]
  }
}




# 
data_5$y_SETAR_1 <- rep(NA, n)
data_5$y_SETAR_1[2:n] <- data_5$y_SETAR[1:(n-1)]
# plot data
ggplot(data_5) +
  geom_point(aes(x = y_SETAR_1, y = y_SETAR, color = "SETAR(2,1,1)"), alpha = 1/2) +
  geom_line(aes(x = y_SETAR_1, y = mean_theo, color = "mean_theo(2,1,1)"), alpha = 1/2) +
  #ylim(0, 1) +
  labs(x = "y(t - 1)", y = "y(t)", color = "") + 
  theme_TS()

```





```{r, fig.cap=fig$cap("ex_12", "")}
#
lags_acf <- data.frame(lag = acf(data_5$mean_theo, y_SETAR = F)$lag, 
                       acf = acf(data_5$mean_theo, y_SETAR = F)$acf,
                       confi = 2/sqrt(length(data_5$y_SETAR)), # from introduction to times series
                       zero = 0)

#
ggplot() +
  geom_segment(data = lags_acf, 
               aes(x = lag, 
                   y = zero, 
                   xend = lag, 
                   yend = acf, colour = "ACF"), 
               alpha = 1/2) +
  # 
  geom_segment(aes(x = min(lags_acf$lag),
                   xend = max(lags_acf$lag),
                   y = lags_acf$confi,
                   yend = lags_acf$confi,
                   colour = "95%"),
               linetype = 2) +
  geom_segment(aes(x = min(lags_acf$lag),
                   xend = max(lags_acf$lag),
                   y = -lags_acf$confi,
                   yend = -lags_acf$confi,
                   colour = "95%"),
               linetype = 2) +
  labs(x = "lag", y = "value", color = "") +
  theme_TS()

```


```{r, fig.cap=fig$cap("ex_13", "")}
#
# load initial functions
source("~/DTU/Courses/Advanced Time Series/Projects/CE_1/r/ldf.R")
source("~/DTU/Courses/Advanced Time Series/Projects/CE_1/r/leaveOneOut.R")
lags_ldf <- ldf(x = data_5$y_SETAR, lags = 1:3, plotIt = FALSE, confidence_interval = 0.95)

#
ggplot() +
  geom_segment(data = lags_ldf, 
               aes(x = lag,
                   y = zero,
                   xend = lag,
                   yend = ldf, colour = "LDF"), 
               alpha = 1/2) +
  # 
  geom_segment(aes(x = min(lags_ldf$lag),
                   xend = max(lags_ldf$lag),
                   y = lags_ldf$confi,
                   yend = lags_ldf$confi,
                   colour = "95%"),
               linetype = 2) +
  #
  #geom_segment(aes(x = min(lags_ldf$lag),
  #                 xend = max(lags_ldf$lag),
  #                 y = -lags_ldf$confi,
  #                 yend = -lags_ldf$confi,
  #                 colour = "95%"),
  #             linetype = 2) +
  labs(x = "lag", y = "value", color = "") +
  theme_TS()

```
