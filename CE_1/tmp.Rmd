

# Part 4

describe the function

```{r, fig.cap=fig$cap("ex_8", "")}
## Number of samplepoints
n <- 3000
## Uniform distributed x
x <- runif(n,-1,1)
## Errors
r <- rnorm(n) / 10
data_4 <- data.frame(t = 1:n, x = x, noise = r, y = rep(NA, n))

data_4$x_1 <- rep(NA, n)
data_4$x_1[2:n] <- data_4$x[1:(n-1)]

# define continuously differentiable function
g <- function(x) {
  #
  return(1 / (1 + exp(-x))) 
  #return(x * x) 
}
#
data_4$y[1] <- mu <- data_4$noise[1]
#
for (t in 2:n) {
  #
  data_4$y[t] <- mu + g(data_4$x[t - 1]) * data_4$y[t - 1] + data_4$noise[t]
}
#
data_4$y_1 <- rep(NA, n)
data_4$y_1[2:n] <- data_4$y[1:(n-1)]

# ggplot(data_4) +
#   geom_line(aes(x = y_1, y = y, color = "y"), alpha = 1/2) +
#   labs(x = "y(t - 1)", y = "y(t)", color = "") +
#   theme_TS()
```
Use these simulated valuues to estimate the dependence of yt on xt 1 and yt 1 using the method of local regression. below 
```{r, fig.cap=fig$cap("ex_9", "")}

##------------------------------------------------
## Estimate the function with local polynomial regression using lm()
## It is possible to use different bandwidths in each dimension.

data_4 <- data_4[-1, ]


## Epanechnikov kernel
kernelEp <- function(xall, x, h) {
  ## Make the weights with an Epanechnikov kernel
  ## h has the same unit as x (i.e. it is on the same absolute scale, so if x is Watt, h is also given in Watt) 
  u <- abs(xall - x)
  u <- u / h
  w <- 3/4 * (1 - u^2)
  ## Set values with |u|>1 to 0
  w[abs(u) > 1] <- 0
  return(w)
}

## Bandwidths in each two-dimensional multiplicative kernel relative to the range of x and y
bandwidth <- 0.3 
hx <- bandwidth * (max(data_4$x_1, na.rm = TRUE) - min(data_4$x_1, na.rm = TRUE))
hy <- bandwidth * (max(data_4$y_1, na.rm = TRUE) - min(data_4$y_1, na.rm = TRUE))


nplot <- 100
x1Seq <- seq(min(data_4$x), max(data_4$x), len = nplot)
y1Seq <- seq(min(data_4$y), max(data_4$y), len = nplot)

open3d() ## Note: Do not use rgl.open()
points3d(data_4$x_1, data_4$y_1, data_4$y, size=3, col="red")
aspect3d(c(1,1,1))
axes3d()
title3d(xlab = "x[t-1]", ylab = "y[t-1]", zlab = "y[t]")


## Do local 1'st order regression. This can also easily be changed to a conditional parametric model
yprd <- outer(x1Seq, y1Seq, function(x1,y1) {
  L <- lapply(1:length(x1), function(i) {
    ## Just a tip for debugging in R: Use browser() to stop inside some function. Quit with "Q", see ?browser
    ##browser()
    ## Calculate the weights in each dimension
    wx <- kernelEp(data_4$x_1, x1[i], h = hx)
    wy <- kernelEp(data_4$y_1, y1[i], h = hy)
    w <- wx * wy
    ## Do it only with positive weights
    ok <- w > 0
    ## Note that this is local first order polynomial regression, but can easily be made 2'nd
    fit <- lm(y ~ x_1 + y_1, weights=w[ok], dat=data_4[ok,])
    return(predict(fit, data.frame(x_1=x1[i], y_1=y1[i])))
  })
  return(do.call("rbind",L))
})
## Draw the surface. See ?rgl.material for options
surface3d(x1Seq, y1Seq, yprd, color="blue", alpha=0.5)


# ggplot(data_4) +
#   geom_line(aes(x = y_1, y = y, color = "y"), alpha = 1/2) +
#   labs(x = "y(t - 1)", y = "y(t)", color = "") +
#   theme_TS()
```
```{r, fig.cap=fig$cap("ex_10", "")}

```

# Part 5
```{r, fig.cap=fig$cap("ex_11", "")}
## Make a time series y with a regime model
data_5 <- subset(data, select = c("t", "x", "noise"))
n <- nrow(data_5)




a0 <- c(2.0, -1.0) # off set
a1 <- c(0.6, -0.4)

data_5$y_SETAR <- rep(NA,n)
data_5$mean_theo <- rep(NA,n)
data_5$y_SETAR[1] <- data_5$noise[1]
for(t in 2:n) {
  if(data_5$y_SETAR[t - 1] <= 0) {
    data_5$y_SETAR[t] <- a0[1] + a1[1] * data_5$y_SETAR[t-1] + data_5$noise[t]
    data_5$mean_theo[t] <- a0[1] + a1[1] * data_5$y_SETAR[t - 1]
  } else {
    data_5$y_SETAR[t] <- a0[2] + a1[2] * data_5$y_SETAR[t-1] + data_5$noise[t]
    data_5$mean_theo[t] <- a0[2] + a1[2] * data_5$y_SETAR[t - 1]
  }
}




# 
data_5$y_SETAR_1 <- rep(NA, n)
data_5$y_SETAR_1[2:n] <- data_5$y_SETAR[1:(n-1)]
# plot data
ggplot(data_5) +
  geom_point(aes(x = y_SETAR_1, y = y_SETAR, color = "SETAR(2,1,1)"), alpha = 1/2) +
  geom_line(aes(x = y_SETAR_1, y = mean_theo, color = "mean_theo(2,1,1)"), alpha = 1/2) +
  #ylim(0, 1) +
  labs(x = "y(t - 1)", y = "y(t)", color = "") + 
  theme_TS()

```





```{r, fig.cap=fig$cap("ex_12", "")}
#
lags_acf <- data.frame(lag = acf(data_5$mean_theo, y_SETAR = F)$lag, 
                       acf = acf(data_5$mean_theo, y_SETAR = F)$acf,
                       confi = 2/sqrt(length(data_5$y_SETAR)), # from introduction to times series
                       zero = 0)

#
ggplot() +
  geom_segment(data = lags_acf, 
               aes(x = lag, 
                   y = zero, 
                   xend = lag, 
                   yend = acf, colour = "ACF"), 
               alpha = 1/2) +
  # 
  geom_segment(aes(x = min(lags_acf$lag),
                   xend = max(lags_acf$lag),
                   y = lags_acf$confi,
                   yend = lags_acf$confi,
                   colour = "95%"),
               linetype = 2) +
  geom_segment(aes(x = min(lags_acf$lag),
                   xend = max(lags_acf$lag),
                   y = -lags_acf$confi,
                   yend = -lags_acf$confi,
                   colour = "95%"),
               linetype = 2) +
  labs(x = "lag", y = "value", color = "") +
  theme_TS()

```


```{r, fig.cap=fig$cap("ex_13", "")}
#
# load initial functions
source("~/DTU/Courses/Advanced Time Series/Projects/CE_1/r/ldf.R")
source("~/DTU/Courses/Advanced Time Series/Projects/CE_1/r/leaveOneOut.R")
lags_ldf <- ldf(x = data_5$y_SETAR, lags = 1:3, plotIt = FALSE, confidence_interval = 0.95)

#
ggplot() +
  geom_segment(data = lags_ldf, 
               aes(x = lag,
                   y = zero,
                   xend = lag,
                   yend = ldf, colour = "LDF"), 
               alpha = 1/2) +
  # 
  geom_segment(aes(x = min(lags_ldf$lag),
                   xend = max(lags_ldf$lag),
                   y = lags_ldf$confi,
                   yend = lags_ldf$confi,
                   colour = "95%"),
               linetype = 2) +
  #
  #geom_segment(aes(x = min(lags_ldf$lag),
  #                 xend = max(lags_ldf$lag),
  #                 y = -lags_ldf$confi,
  #                 yend = -lags_ldf$confi,
  #                 colour = "95%"),
  #             linetype = 2) +
  labs(x = "lag", y = "value", color = "") +
  theme_TS()

```
