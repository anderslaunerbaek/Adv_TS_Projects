---
title: 'Advanced Time Series Analysis: Computer Exercise 3'
author: "Anders Launer Bæk (s160159)"
date: "`r format(Sys.time(), '%d %B %Y')`"
header-includes: 
    - \usepackage{graphicx}
output:
  pdf_document: default
---

```{r setup, include=FALSE}
rm(list = ls())

knitr::opts_chunk$set(echo = FALSE, 
                      include = TRUE,
                      warning = FALSE,
                      fig.width = 8, fig.height = 4,
                      fig.show='hold', fig.align='center',
                      
                      eval = TRUE, 
                      tidy = TRUE, 
                      dev = 'pdf', 
                      cache = TRUE, fig.pos = "th!")

kable_format <- list(small.mark = ",",
                     big.mark = ',',
                     decimal.mark = '.',
                     nsmall = 3,
                     digits = 3,
                     scientific = FALSE,
                     big.interval = 3L)

library(ggplot2)
theme_TS <- function(base_size = 9, base_family = "", face = "plain"){
  theme_bw(base_size = base_size, base_family = base_family) %+replace%
    theme(panel.background = element_blank(), 
          panel.border = element_blank(),
          panel.grid = element_blank(),
          axis.text = element_text(size = base_size, face = face, family = base_family),
          axis.title = element_text(size = base_size, face = face, family = base_family),
          legend.text = element_text(size = base_size, face = face, family = base_family))
}

# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}


```
Sparring partners:
\begin{itemize}
\item Anja Liljedahl Christensen (s162876)
\item Marie Mørk (s112770)
\end{itemize}

## Part 1: Simulation and discretization of diffusion processes
```{r}
Theta <- c(0.7, 0.8, 3.0, -0.34)
delta <- 2^-9
sigma <- 0
T <- 100
t <- seq(from = 0, to = T, by = delta)
```

Equation 2a and 2b from the description have been discretized and they are showed in eqn. \ref{eqn_1_1}.
\begin{equation}
\begin{aligned}
Y_{n+1}^1 &= Y_n^1+ \theta_3\left(Y_n^1 + Y_n^2 - \frac{1}{3}\left(Y_n^1  \right)^3 + \theta_4  \right)\Delta+\sigma\Delta W^1_{n+1} \\
Y_{n+1}^2 &= Y_n^2 - \frac{1}{\theta_3} \left(Y_n^1 +\theta_2Y_n^2 - \theta_1  \right) \Delta
\end{aligned}
\label{eqn_1_1}
\end{equation}

The initial parameters for this diffusion process are given in eqn. \ref{eqn_1_2}.

\begin{equation}
\begin{aligned}
\theta_{1,2,3,4} &= [`r Theta[1]`,\,`r Theta[2]`,\,`r Theta[3]`,\,`r Theta[4]`] \\
\Delta &= `r delta` \\
\sigma &= `r sigma` \\
T &= `r T` \\
t &= 1:\Delta:T \\
\Delta W^1_{n+1} &\sim \mathcal{N}\left(0,\,\Delta  \right)
\end{aligned}
\label{eqn_1_2}
\end{equation}


### Question 1a
It is possible to change the process by changes the value of $\sigma$. An increase in $\sigma$ will provide a bigger variation in the Wiener process. Below there have been plotted relizations of $Y_k^1$ and $Y_k^2$ wrt. time and a phase plot of $Y_k^1$ and $Y_k^2$. 
The following function `model_func()` has been used to plot 

```{r, echo=TRUE}
# function ----
model_func <- function(sigma, delta, t, Theta, init_values) {
  # initilize data.frame and initial values
  data <- data.frame(T = t, Y_1 = NA, Y_2 = NA)
  data$Y_1[1] <- init_values[1]
  data$Y_2[1] <- init_values[2]
  # simulate winer process
  set.seed(22)
  data$W <- rnorm(nrow(data), mean = 0, sd = delta)
  # run the simulation
  # loop
  for(k in 1:(nrow(data)-1)){
    # Y_k^1
    data$Y_1[k + 1] <- data$Y_1[k] + Theta[3] * 
      (data$Y_1[k] + data$Y_2[k] - 1/3 * data$Y_1[k]^3 
       + Theta[4]) * delta + sigma  * data$W[k + 1]
    # Y_k^2
    data$Y_2[k + 1] <- data$Y_2[k] - 1/Theta[3] * 
      (data$Y_1[k] + Theta[2] * data$Y_2[k] - Theta[1]) * delta
  }
  # realizations
  re_plot <- ggplot2::ggplot(data) + 
    ggplot2::geom_point(ggplot2::aes(x = T, y = Y_1, color = "Y_k^1"), alpha = 1/2) +
    ggplot2::geom_point(ggplot2::aes(x = T, y = Y_2, color = "Y_k^2"), alpha = 1/2) +
    ggplot2::labs(x = "t", y = "Y_k^*(t) ", color = "") +
    theme_TS()
  # phase
  ph_plot <- ggplot2::ggplot(data) + 
    ggplot2::geom_point(ggplot2::aes(x = Y_1, y = Y_2, color = "Phase"), alpha = 1/2) +
    ggplot2::labs(x = "Y_k^1(t)", y = "Y_k^2(t)", color = "") +
    theme_TS()
  return(list("sim" = data, "re_plot" = re_plot, "ph_plot" = ph_plot))
}
```
\newpage
#### $\sigma = 0.00$

```{r, fig.cap="\\label{fig_ex_1_11}Plot of the simulation realizations with sigma = 0.0."}
tmp <- model_func(sigma = 0.0, delta = delta, t = t, Theta = Theta, init_values = c(-1.9, 1.2))
tmp$re_plot
```

```{r, fig.cap="\\label{fig_ex_1_12}Phase plot of the simulation with sigma = 0.0."}
tmp$ph_plot
```
\newpage
#### $\sigma = 0.10$

```{r, fig.cap="\\label{fig_ex_1_21}Plot of the simulation realizations with sigma = 0.10."}
tmp <- model_func(sigma = 0.1, delta = delta, t = t, Theta = Theta, init_values = c(-1.9, 1.2))
tmp$re_plot
```

```{r, fig.cap="\\label{fig_ex_1_22}Phase plot of the simulation with sigma = 0.10."}
tmp$ph_plot
```
\newpage
#### $\sigma = 0.20$

```{r, fig.cap="\\label{fig_ex_1_31}Plot of the simulation realizations with sigma = 0.20."}
tmp <- model_func(sigma = 0.2, delta = delta, t = t, Theta = Theta, init_values = c(-1.9, 1.2))
tmp$re_plot
```

```{r, fig.cap="\\label{fig_ex_1_32}Phase plot of the simulation with sigma = 0.20."}
tmp$ph_plot
```
\newpage
#### $\sigma = 0.30$

```{r, fig.cap="\\label{fig_ex_1_41}Plot of the simulation realizations with sigma = 0.30."}
tmp <- model_func(sigma = 0.3, delta = delta, t = t, Theta = Theta, init_values = c(-1.9, 1.2))
tmp$re_plot
```

```{r, fig.cap="\\label{fig_ex_1_42}Phase plot of the simulation with sigma = 0.30."}
tmp$ph_plot
```
\newpage
#### $\sigma = 0.40$

```{r, fig.cap="\\label{fig_ex_1_51}Plot of the simulation realizations with sigma = 0.40."}
tmp <- model_func(sigma = 0.4, delta = delta, t = t, Theta = Theta, init_values = c(-1.9, 1.2))
tmp$re_plot
```

```{r, fig.cap="\\label{fig_ex_1_52}Phase plot of the simulation with sigma = 0.40."}
tmp$ph_plot
```
\newpage
#### Comment on the effect of adding noise to the equations
\begin{itemize}
\item 
\end{itemize}

### Question 1b

#### $\sigma = 0.10$

```{r, fig.cap="\\label{fig_ex_1b_1}Phase plot of the simulation with sigma = 0.10."}
grid <- 100

tmp <- model_func(sigma = 0.1, delta = delta, t = t, Theta = Theta, init_values = c(-1.9, 1.2))
#
ggplot(tmp$sim, aes(x = Y_1, y = Y_2)) + 
  stat_bin2d(bins = grid) +
  labs(x = "Y_k^1(t)", y = "Y_k^2(t)", color = "") +
  theme_TS()
```


#### $\sigma = 0.20$

```{r, fig.cap="\\label{fig_ex_1b_2}Phase plot of the simulation with sigma = 0.20."}
tmp <- model_func(sigma = 0.2, delta = delta, t = t, Theta = Theta, init_values = c(-1.9, 1.2))
#
ggplot(tmp$sim, aes(x = Y_1, y = Y_2)) + 
  stat_bin2d(bins = grid) +
  labs(x = "Y_k^1(t)", y = "Y_k^2(t)", color = "") +
  theme_TS()
```

#### $\sigma = 0.30$

```{r, fig.cap="\\label{fig_ex_1b_3}Phase plot of the simulation with sigma = 0.30."}
tmp <- model_func(sigma = 0.3, delta = delta, t = t, Theta = Theta, init_values = c(-1.9, 1.2))
#
ggplot(tmp$sim, aes(x = Y_1, y = Y_2)) + 
  stat_bin2d(bins = grid) +
  labs(x = "Y_k^1(t)", y = "Y_k^2(t)", color = "") +
  theme_TS()
```

#### $\sigma = 0.40$

```{r, fig.cap="\\label{fig_ex_1b_4}Phase plot of the simulation with sigma = 0.40."}
tmp <- model_func(sigma = 0.4, delta = delta, t = t, Theta = Theta, init_values = c(-1.9, 1.2))
#
ggplot(tmp$sim, aes(x = Y_1, y = Y_2)) + 
  stat_bin2d(bins = grid) +
  labs(x = "Y_k^1(t)", y = "Y_k^2(t)", color = "") +
  theme_TS()
```


#### Which extra information does the plot contain, compared to the standard phase-plot?
\begin{itemize}
\item 
\end{itemize}

















## Part 2: 
### Data
```{r}
rm(list = c("tmp","delta","sigma","grid","T","t","Theta","model_func"))

# global parameters ----
prm <- list()
# latitude and longitude for the location of the house
prm$latitude <- 55.791038
prm$longitude <- 12.525545
# load 
data <- read.csv(file = "~/DTU/Courses/Advanced Time Series/Projects/CE_3/data.csv", 
                 stringsAsFactors = FALSE)
## Take the needed series
data <- data[,c(1,2,4,5,6,3)]
## Give names to the series
names(data) <- c("timedate","yTi","Ta","Gv","Ph","Tn")
# load functions 
files <- dir("~/DTU/Courses/Advanced Time Series/Projects/CE_3/r/functions", full.names=TRUE)
for(i in 1:length(files)) source(files[i])

# modify dates 
data$timedate <- asP(data$timedate)
## timedate is the time in POSIXct, make t in hours since begining
data$t <- asHours(data$timedate-data$timedate[1])
```


describe the data
### Question 2a
#### 1. Step
```{r}
p1 <- ggplot2::ggplot(data) + 
  ggplot2::geom_line(aes(x = timedate, y = Ph, color = "Ph"), alpha = 1/2) +
  labs(x = "", y = "", color = "") +
  theme_TS() +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

p2 <- ggplot2::ggplot(data) + 
  ggplot2::geom_line(aes(x = timedate, y = Ta, color = "TA"), alpha = 1/2) +
  ggplot2::geom_line(aes(x = timedate, y = yTi, color = "yTi"), alpha = 1/2) +
  ggplot2::geom_line(aes(x = timedate, y = Tn, color = "Tn"), alpha = 1/2) +
  labs(x = "", y = "", color = "") +
  ylim(0, 45) +
  theme_TS() +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
  

p3 <- ggplot2::ggplot(data) + 
  ggplot2::geom_line(aes(x = timedate, y = Gv, color = "Gv"), alpha = 1/2) +
  labs(x = "timedate", y = "", color = "") +
  theme_TS()

multiplot(p1, p2, p3, cols=1)
```
#### 2. Step


figure \ref{}

adasd

```{r}
## Fit a SDE model for the heat dynamics of the East room
## Generate a new object of class ctsm
library(ctsmr)
model <- ctsm()
## Add a system equation and thereby also a state
model$addSystem(dTi ~ ( 1/(Ci*Ria)*(Ta-Ti) + 1/Ci*Ph )*dt + exp(p11)*dw1)
## Set the names of the inputs
model$addInput(Ta,Gv,Ph)
## Set the observation equation: Ti is the state, yTi is the measured output
model$addObs(yTi ~ Ti)
## Set the variance of the measurement error
model$setVariance(yTi ~ exp(e11))
## Set the initial value (for the optimization) of the value of the state at the starting time point
model$setParameter(  Ti0 = c(init=15  ,lb=0     ,ub=25 ) )
## Set the initial value for the optimization
model$setParameter(  Ci = c(init=1   ,lb=1E-5  ,ub=20 ) )
model$setParameter( Ria = c(init=5   ,lb=1     ,ub=10) )
model$setParameter( p11 = c(init=1   ,lb=-30   ,ub=10 ) )
model$setParameter( e11 = c(init=-1  ,lb=-50   ,ub=10 ) )
## Run the parameter optimization
fit <- model$estimate(data)
```
```{r}
analyzeFit(fit, plotit = FALSE)
summary(fit, extended = TRUE)
```



#### 3. Step
```{r}
analyzeFit(fit, plotit = FALSE)
```

The optimization procedure works out without any problems, but if we look at the extended summary of the fit then dPen/dPar is rather large for one of the parameters. What does this mean and how to fix the associated problem?


Issue: Ria  and Ti0 are binding

see the manuel and fix the fix
```{r}
##----------------------------------------------------------------

## Be a bit smart and do the same in a function, see functions/Ti.R
model.Ti <- ctsm()
## Add a system equation and thereby also a state
model.Ti$addSystem(dTi ~ ( 1/(Ci*Ria)*(Ta-Ti) + 1/Ci*Ph )*dt + exp(p11)*dw1)
## Set the names of the inputs
model.Ti$addInput(Ta,Gv,Ph)
## Set the observation equation: Ti is the state, yTi is the measured output
model.Ti$addObs(yTi ~ Ti)
## Set the variance of the measurement error
model.Ti$setVariance(yTi ~ exp(e11))
## Set the initial value (for the optimization) of the value of the state at the starting time point
model.Ti$setParameter(  Ti0 = c(init=15  ,lb=0     ,ub=35 ) )
## Set the initial value for the optimization
model.Ti$setParameter(  Ci = c(init=1   ,lb=1E-5  ,ub=20 ) )
model.Ti$setParameter( Ria = c(init=5   ,lb=1     ,ub=100) )
model.Ti$setParameter( p11 = c(init=1   ,lb=-30   ,ub=10 ) )
model.Ti$setParameter( e11 = c(init=-1  ,lb=-50   ,ub=10 ) )
## Run the parameter optimization
fit.Ti <- model.Ti$estimate(data)
```

```{r}
analyzeFit(fit.Ti, plotit = FALSE)
summary(fit.Ti, extended = TRUE)
```


#### 4. Step

One-step ahead residuals

```{r}
## Calculate the one-step predictions of the state
pred <- predict(fit)
## Calculate the residuals and put them with the data
data$yTiHat <- pred[[1]]$output$pred$yTi
data$residuals <- data$yTi - data$yTiHat
```

##### Time Series of the residuals
```{r}
ggplot(data) +
  geom_line(aes(x = timedate, y = residuals, color = "Residuals"), alpha = 1/2) +
  labs(x = "timedate", y = "", color = "") +
  theme_TS()
```
##### Distribution of the residuals
```{r}
ggplot(data) +
  geom_histogram(aes(x = residuals, color = "Residuals"), alpha = 1/2) +
  labs(x = "epsilon", y = "frequency", color = "") +
  theme_TS()
```

##### ACF of the residuals

```{r}
lags_acf <- data.frame(lag = acf(data$residuals, plot = F, lag.max=8*24)$lag,
                       acf = acf(data$residuals, plot = F, lag.max=8*24)$acf,
                       confi = qnorm((1 + 0.95)/2)/sqrt(length(data$residuals)), # from introduction to times series
                       zero = 0)
#
ggplot() +
  geom_segment(data = lags_acf,
               aes(x = lag, y = zero,
                   xend = lag, yend = acf,
                   colour = "ACF"),
               alpha = 1/2) +
  #
  geom_segment(aes(x = min(lags_acf$lag),
                   xend = max(lags_acf$lag),
                   y = lags_acf$confi,
                   yend = lags_acf$confi,
                   colour = "95%"),
               linetype = 2) +
  geom_segment(aes(x = min(lags_acf$lag),
                   xend = max(lags_acf$lag),
                   y = -lags_acf$confi,
                   yend = -lags_acf$confi,
                   colour = "95%"),
               linetype = 2) +
  ylim(-0.25,1) +
  scale_x_continuous(breaks = seq(from = 0, to = max(lags_acf$lag), by = 10)) + 
  labs(x = "lag", y = "value", color = "") +
  theme_TS()
```


##### Periodogram of the residuals

```{r}
# The periodogram is the estimated energy spectrum in the signal
tmp <- spec.pgram(data$residuals, plot = FALSE)
spec_pgram_df <- data.frame(freq = tmp$freq,
                            spec = tmp$spec)
ggplot(spec_pgram_df) +
  geom_line(aes(x = freq, y = spec, colour = paste("raw periodogram\nbandwidth = ", round(tmp$bandwidth,3))), alpha = 1/2) +
  labs(x = "frequency", y = "spectrum (log10)", color = "") +
  scale_x_continuous() + scale_y_log10() + 
  theme_TS()
```



##### Commulated Periodogram of the residuals
```{r}
# function ----
cpgram_func <- function (ts, taper = 0.1) {
    
    if (NCOL(ts) > 1) 
        stop("only implemented for univariate time series")
    x <- as.vector(ts)
    x <- x[!is.na(x)]
    x <- spec.taper(scale(x, TRUE, FALSE), p = taper)
    y <- Mod(fft(x))^2/length(x)
    y[1L] <- 0
    n <- length(x)
    x <- (0:(n/2)) * frequency(ts)/n
    if (length(x)%%2 == 0) {
        n <- length(x) - 1
        y <- y[1L:n]
        x <- x[1L:n]
    }
    else y <- y[seq_along(x)]
    xm <- frequency(ts)/2
    mp <- length(x) - 1
    crit <- 1.358/(sqrt(mp) + 0.12 + 0.11/sqrt(mp))
    oldpty <- par(pty = "s")
    on.exit(par(oldpty))
    return(list("df" = data.frame(x=x,y=cumsum(y)/sum(y)), 
                "xlim" = c(0, xm), "ylim" = c(0, 1),
                "confi_upper" = c(c(0, xm * (1 - crit)), c(crit, 1)),
                "confi_lower" = c(c(xm * crit, xm), c(0, 1 - crit))
                ))
}


# plot ----
cpgram <- cpgram_func(data$residuals)
ggplot() +
  geom_point(data = cpgram$df, aes(x = x, y = y, color = "cpgram"), alpha = 1/2) +
  geom_segment(aes(x = cpgram$confi_upper[1],
                   y = cpgram$confi_upper[3],
                   xend = cpgram$confi_upper[2],
                   yend = cpgram$confi_upper[4], colour = "CI"),
               alpha = 1/2) +
  geom_segment(aes(x = cpgram$confi_lower[1],
                   y = cpgram$confi_lower[3],
                   xend = cpgram$confi_lower[2],
                   yend = cpgram$confi_lower[4], colour = "CI"),
               alpha = 1/2) +
  labs(x = "frequency", y = "", color = "") +
  theme_TS()
```

##### combined
```{r}
data$zero <- 0
p1 <- ggplot(data) +
  geom_line(aes(x = timedate, y = residuals, color = "Residuals"), alpha = 1/2) +
  geom_line(aes(x = timedate, y = zero, color = "zero"), alpha = 1/2) +
  labs(x = "timedate", y = "", color = "") +
  theme_TS() +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())


p2 <- ggplot(data) +
  geom_line(aes(x = timedate, y = Ph, color = "Ph"), alpha = 1/2) +
  labs(x = "timedate", y = "", color = "") +
  theme_TS() +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

p3 <- ggplot2::ggplot(data) + 
  ggplot2::geom_line(aes(x = timedate, y = yTi, color = "measured"), alpha = 1/2) +
  ggplot2::geom_line(aes(x = timedate, y = yTiHat, color = "predicted"), alpha = 1/2) +
  labs(x = "", y = "", color = "") +
  #ylim(0, 45) +
  theme_TS() +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
  

p4 <- ggplot2::ggplot(data) + 
  ggplot2::geom_line(aes(x = timedate, y = Ta, color = "Ta"), alpha = 1/2) +
  labs(x = "timedate", y = "", color = "") +
  theme_TS() +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

p5 <- ggplot2::ggplot(data) + 
  ggplot2::geom_line(aes(x = timedate, y = Gv, color = "Gv"), alpha = 1/2) +
  labs(x = "timedate", y = "", color = "") +
  theme_TS()

multiplot(p1, p2, p3, p4, p5, cols=1)
```




#### 5. Step

figure \ref{} new

```{r}
## A two-state model implemented in functions/TiTm.R
model.TiTm <- ctsm()
## Add a system equation and thereby also a state
model.TiTm$addSystem(dTi ~ ( 1/(Ci*Rim)*(Tm-Ti) + 1/(Ci*Ria)*(Ta-Ti) + 1/Ci*Ph  )*dt + exp(p11)*dw1 )
model.TiTm$addSystem(dTm ~ ( 1/(Cm*Rim)*(Ti-Tm))*dt + exp(p22)*dw2 )
## Set the names of the inputs
model.TiTm$addInput(Ta,Ph)
## Set the observation equation: Ti is the state, yTi is the measured output
model.TiTm$addObs(yTi ~ Ti)
## Set the variance of the measurement error
model.TiTm$setVariance(yTi ~ exp(e11))
## Set the initial value (for the optimization) of the value of the state at the starting time point
model.TiTm$setParameter(  Ti = c(init=25  ,lb=0     ,ub=40) )
model.TiTm$setParameter(  Tm = c(init=25  ,lb=0     ,ub=40) )
## Set the initial value for the optimization
model.TiTm$setParameter(  Ci = c(init=1   ,lb=1E-5  ,ub=20) )
model.TiTm$setParameter(  Cm = c(init=1   ,lb=1E-4  ,ub=100))
model.TiTm$setParameter( Ria = c(init=20  ,lb=1     ,ub=1E5))
model.TiTm$setParameter( Rim = c(init=1   ,lb=1E-4  ,ub=100))
model.TiTm$setParameter( p11 = c(init=1   ,lb=-30   ,ub=10) )
model.TiTm$setParameter( p22 = c(init=1   ,lb=-30   ,ub=10) )
model.TiTm$setParameter( e11 = c(init=-1  ,lb=-50   ,ub=10) )    
## Run the parameter optimization
fit.TiTm <- model.TiTm$estimate(data)
```

```{r}
analyzeFit(fit.TiTm, plotit = FALSE)
```


#### 6. Step

```{r}
## Calculate the one-step predictions of the state
pred <- predict(fit.TiTm)
## Calculate the residuals and put them with the data
data$yTiHat <- pred[[1]]$output$pred$yTi
data$residuals <- data$yTi - data$yTiHat
```

##### Time Series of the residuals
```{r}
ggplot(data) +
  geom_line(aes(x = timedate, y = residuals, color = "Residuals"), alpha = 1/2) +
  labs(x = "timedate", y = "", color = "") +
  theme_TS()
```
##### Distribution of the residuals
```{r}
ggplot(data) +
  geom_histogram(aes(x = residuals, color = "Residuals"), alpha = 1/2) +
  labs(x = "epsilon", y = "frequency", color = "") +
  theme_TS()
```

##### ACF of the residuals

```{r}
lags_acf <- data.frame(lag = acf(data$residuals, plot = F, lag.max=8*24)$lag,
                       acf = acf(data$residuals, plot = F, lag.max=8*24)$acf,
                       confi = qnorm((1 + 0.95)/2)/sqrt(length(data$residuals)), # from introduction to times series
                       zero = 0)
#
ggplot() +
  geom_segment(data = lags_acf,
               aes(x = lag, y = zero,
                   xend = lag, yend = acf,
                   colour = "ACF"),
               alpha = 1/2) +
  #
  geom_segment(aes(x = min(lags_acf$lag),
                   xend = max(lags_acf$lag),
                   y = lags_acf$confi,
                   yend = lags_acf$confi,
                   colour = "95%"),
               linetype = 2) +
  geom_segment(aes(x = min(lags_acf$lag),
                   xend = max(lags_acf$lag),
                   y = -lags_acf$confi,
                   yend = -lags_acf$confi,
                   colour = "95%"),
               linetype = 2) +
  ylim(-0.25,1) +
  scale_x_continuous(breaks = seq(from = 0, to = max(lags_acf$lag), by = 10)) + 
  labs(x = "lag", y = "value", color = "") +
  theme_TS()
```

##### Periodogram of the residuals

```{r}
# The periodogram is the estimated energy spectrum in the signal
tmp <- spec.pgram(data$residuals, plot = FALSE)
spec_pgram_df <- data.frame(freq = tmp$freq,
                            spec = tmp$spec)
ggplot(spec_pgram_df) +
  geom_line(aes(x = freq, y = spec, colour = paste("raw periodogram\nbandwidth = ", round(tmp$bandwidth,3))), alpha = 1/2) +
  labs(x = "frequency", y = "spectrum (log10)", color = "") +
  scale_x_continuous() + scale_y_log10() + 
  theme_TS()
```



##### Commulated Periodogram of the residuals
```{r}
# function ----
cpgram_func <- function (ts, taper = 0.1) {
    
    if (NCOL(ts) > 1) 
        stop("only implemented for univariate time series")
    x <- as.vector(ts)
    x <- x[!is.na(x)]
    x <- spec.taper(scale(x, TRUE, FALSE), p = taper)
    y <- Mod(fft(x))^2/length(x)
    y[1L] <- 0
    n <- length(x)
    x <- (0:(n/2)) * frequency(ts)/n
    if (length(x)%%2 == 0) {
        n <- length(x) - 1
        y <- y[1L:n]
        x <- x[1L:n]
    }
    else y <- y[seq_along(x)]
    xm <- frequency(ts)/2
    mp <- length(x) - 1
    crit <- 1.358/(sqrt(mp) + 0.12 + 0.11/sqrt(mp))
    oldpty <- par(pty = "s")
    on.exit(par(oldpty))
    return(list("df" = data.frame(x=x,y=cumsum(y)/sum(y)), 
                "xlim" = c(0, xm), "ylim" = c(0, 1),
                "confi_upper" = c(c(0, xm * (1 - crit)), c(crit, 1)),
                "confi_lower" = c(c(xm * crit, xm), c(0, 1 - crit))
                ))
}


# plot ----
cpgram <- cpgram_func(data$residuals)
ggplot() +
  geom_point(data = cpgram$df, aes(x = x, y = y, color = "cpgram"), alpha = 1/2) +
  geom_segment(aes(x = cpgram$confi_upper[1],
                   y = cpgram$confi_upper[3],
                   xend = cpgram$confi_upper[2],
                   yend = cpgram$confi_upper[4], colour = "CI"),
               alpha = 1/2) +
  geom_segment(aes(x = cpgram$confi_lower[1],
                   y = cpgram$confi_lower[3],
                   xend = cpgram$confi_lower[2],
                   yend = cpgram$confi_lower[4], colour = "CI"),
               alpha = 1/2) +
  labs(x = "frequency", y = "", color = "") +
  theme_TS()
```

##### combined
```{r}
data$zero <- 0
p1 <- ggplot(data) +
  geom_line(aes(x = timedate, y = residuals, color = "Residuals"), alpha = 1/2) +
  geom_line(aes(x = timedate, y = zero, color = "zero"), alpha = 1/2) +
  labs(x = "timedate", y = "", color = "") +
  theme_TS() +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())


p2 <- ggplot(data) +
  geom_line(aes(x = timedate, y = Ph, color = "Ph"), alpha = 1/2) +
  labs(x = "timedate", y = "", color = "") +
  theme_TS() +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

p3 <- ggplot2::ggplot(data) + 
  ggplot2::geom_line(aes(x = timedate, y = yTi, color = "measured"), alpha = 1/2) +
  ggplot2::geom_line(aes(x = timedate, y = yTiHat, color = "predicted"), alpha = 1/2) +
  labs(x = "", y = "", color = "") +
  #ylim(0, 45) +
  theme_TS() +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
  

p4 <- ggplot2::ggplot(data) + 
  ggplot2::geom_line(aes(x = timedate, y = Ta, color = "Ta"), alpha = 1/2) +
  labs(x = "timedate", y = "", color = "") +
  theme_TS() +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

p5 <- ggplot2::ggplot(data) + 
  ggplot2::geom_line(aes(x = timedate, y = Gv, color = "Gv"), alpha = 1/2) +
  labs(x = "timedate", y = "", color = "") +
  theme_TS()

multiplot(p1, p2, p3, p4, p5, cols=1)
```







#### 7. Step

```{r}
## Perform a likelihood ratio test: lambda = lik(smallerModel)/lik(largerModel) ,
## where the smallerModel is submodel of the largerModel and lambda is chi2(f)
## distributed with f=dim(smallerModel)-dim(largerModel). Page 20 in Madsen2006.
##
## Get the logLikelihood for both models from their fit
logLikSmall <- fit.Ti$loglik
logLikLarge <- fit.TiTm$loglik
## Calculate the test statistic
chisqStat <- -2 * (logLikSmall - logLikLarge)
## It this gives a p-value smaller than confidence limit, e.g. 5%, then the
## larger model is significant better than the smaller model
prmDiff <- fit.TiTm$model$NPARAM - fit.Ti$model$NPARAM
## The p-value
p_value <- 1 - pchisq(chisqStat, prmDiff)
```

The P value from $`r p_value`$

#### Consider the following
\begin{itemize}
\item Discuss the white-noise properties of the (one-step ahead) residuals for model $T_i$.
\begin{itemize}
\item 
\item
\end{itemize}
\item What useful information can be obtained from the time series plots of the residuals and the inputs for model $T_i$?
\begin{itemize}
\item 
\item
\end{itemize}
\item Discuss the white-noise properties of the one-step ahead residuals for model $T_iT_m$.
\begin{itemize}
\item 
\item
\end{itemize}
\item What useful information can be obtained from the time series plots of the residuals
and inputs for model $T_iT_m$?
\begin{itemize}
\item 
\item
\end{itemize}
\item Based on the likelihood-ratio test is model $T_iT_m$ then to be preferred over model $T_i$?
\begin{itemize}
\item 
\item
\end{itemize}
\end{itemize}

### Question 2b

Describe the good way to implement it...!


what is Aw, Gv and p.. must
```{r, echo = TRUE}
## A two-state model implemented in functions/TiTm.R
model.TiTm_2b <- ctsm()
## Add a system equation and thereby also a state
model.TiTm_2b$addSystem(dTi ~ ( 1/(Ci*Rim)*(Tm-Ti) + 1/(Ci*Ria)*(Ta-Ti) + (p*Aw)/Ci*Gv + 1/Ci*Ph  )*dt + exp(p11)*dw1 )
model.TiTm_2b$addSystem(dTm ~ ( 1/(Cm*Rim)*(Ti-Tm) + ((1 - p) * Aw)/Cm * Gv)*dt + exp(p22)*dw2 )
## Set the names of the inputs
model.TiTm_2b$addInput(Ta,Ph, Gv)
## Set the observation equation: Ti is the state, yTi is the measured output
model.TiTm_2b$addObs(yTi ~ Ti)
## Set the variance of the measurement error
model.TiTm_2b$setVariance(yTi ~ exp(e11))
## Set the initial value (for the optimization) of the value of the state at the starting time point
model.TiTm_2b$setParameter(  Ti = c(init=25  ,lb=0     ,ub=40) )
model.TiTm_2b$setParameter(  Tm = c(init=25  ,lb=0     ,ub=40) )
## Set the initial value for the optimization
model.TiTm_2b$setParameter(  Ci = c(init=1   ,lb=1E-5  ,ub=20) )
model.TiTm_2b$setParameter(  Cm = c(init=1   ,lb=1E-4  ,ub=100))
model.TiTm_2b$setParameter( Ria = c(init=20  ,lb=1     ,ub=1E5))
model.TiTm_2b$setParameter( Rim = c(init=1   ,lb=1E-4  ,ub=100))
model.TiTm_2b$setParameter( p11 = c(init=1   ,lb=-30   ,ub=10) )
model.TiTm_2b$setParameter( p22 = c(init=1   ,lb=-30   ,ub=10) )
model.TiTm_2b$setParameter( e11 = c(init=-1  ,lb=-50   ,ub=10) )

model.TiTm_2b$setParameter( p = c(init=0.5  ,lb=0   ,ub=1) )
model.TiTm_2b$setParameter( Aw = 7.5+4.8 )
#model.TiTm_2b$setParameter( Gv = c(init=mean(data$Gv)  ,lb=min(data$Gv)   ,ub=max(data$Gv)) )

## Run the parameter optimization
fit.TiTm_2b <- model.TiTm_2b$estimate(data)
```



```{r}
analyzeFit(fit.TiTm_2b, plotit = FALSE)
prm$fit.TiTm_2b$Ci <- data.frame(summary(fit.TiTm_2b)$coefficients)["Ci","Estimate"]
prm$fit.TiTm_2b$Cm <- data.frame(summary(fit.TiTm_2b)$coefficients)["Cm","Estimate"]
prm$fit.TiTm_2b$loglik <- fit.TiTm_2b$loglik
```

```{r}
## Calculate the one-step predictions of the state
pred <- predict(fit.TiTm_2b)
## Calculate the residuals and put them with the data
data$yTiHat_2b <- pred[[1]]$output$pred$yTi
data$residuals_2b <- data$yTi - data$yTiHat_2b
```

#### Consider
\begin{itemize}
\item Findings
\begin{itemize}
\item Plot of the resi
```{r}
ggplot(data) +
  geom_line(aes(x = Gv, y = residuals, color = "Residuals(Gv)"), alpha = 1/2) +
  geom_line(aes(x = Gv, y = residuals_2b, color = "Residuals(Gv)2"), alpha = 1/2) +
  #geom_line(aes(x = residuals, y = residuals_2b, color = "Residuals(Gv)2"), alpha = 1/2) +
  labs(x = "Gv", y = "residuals", color = "") +
  theme_TS()

```

\item Changes in squard residuals: 
\begin{itemize}
\item Question 2a: `r sum(data$residuals^2)`
\item Question 2b: `r sum(data$residuals_2b^2)`
\end{itemize}
\end{itemize}
\item Likelihood 
\begin{itemize}
\item Question 2a: `r fit.TiTm$loglik`
\item Question 2b: `r prm$fit.TiTm_2b$loglik`
\end{itemize}

\item Likelihood ratio test
```{r}
## Perform a likelihood ratio test: lambda = lik(smallerModel)/lik(largerModel) ,
## where the smallerModel is submodel of the largerModel and lambda is chi2(f)
## distributed with f=dim(smallerModel)-dim(largerModel). Page 20 in Madsen2006.
##
## Get the logLikelihood for both models from their fit
logLikSmall <- fit.TiTm$loglik
logLikLarge <- fit.TiTm_2b$loglik
## Calculate the test statistic
chisqStat <- -2 * (logLikSmall - logLikLarge)
## It this gives a p-value smaller than confidence limit, e.g. 5%, then the
## larger model is significant better than the smaller model
prmDiff <- fit.TiTm_2b$model$NPARAM - fit.TiTm$model$NPARAM
## The p-value
p_value <- 1 - pchisq(chisqStat, prmDiff)
```

The P value from $`r p_value`$
\item Conclusion: 
\end{itemize}


### Question 2c
Describe how i changed input
```{r}
data <- read.csv(file = "~/DTU/Courses/Advanced Time Series/Projects/CE_3/data.csv", 
                 stringsAsFactors = FALSE)
## Take the needed series
data <- data[,c(1,3,4,5,7,2)]
## Give names to the series
names(data) <- c("timedate","yTi","Ta","Gv","Ph","Tn")
# modify dates 
data$timedate <- asP(data$timedate)
## timedate is the time in POSIXct, make t in hours since begining
data$t <- asHours(data$timedate-data$timedate[1])
```


```{r, echo = TRUE}
## A two-state model implemented in functions/TiTm.R
model.TiTm_2c <- ctsm()
## Add a system equation and thereby also a state
model.TiTm_2c$addSystem(dTi ~ ( 1/(Ci*Rim)*(Tm-Ti) + 1/(Ci*Ria)*(Ta-Ti) + (p*Aw)/Ci*Gv + 1/Ci*Ph  )*dt + exp(p11)*dw1 )
model.TiTm_2c$addSystem(dTm ~ ( 1/(Cm*Rim)*(Ti-Tm) + ((1 - p) * Aw)/Cm * Gv)*dt + exp(p22)*dw2 )
## Set the names of the inputs
model.TiTm_2c$addInput(Ta,Ph, Gv)
## Set the observation equation: Ti is the state, yTi is the measured output
model.TiTm_2c$addObs(yTi ~ Ti)
## Set the variance of the measurement error
model.TiTm_2c$setVariance(yTi ~ exp(e11))
## Set the initial value (for the optimization) of the value of the state at the starting time point
model.TiTm_2c$setParameter(  Ti = c(init=25  ,lb=0     ,ub=40) )
model.TiTm_2c$setParameter(  Tm = c(init=25  ,lb=0     ,ub=40) )
## Set the initial value for the optimization
model.TiTm_2c$setParameter(  Ci = c(init=1   ,lb=1E-5  ,ub=20) )
model.TiTm_2c$setParameter(  Cm = c(init=1   ,lb=1E-4  ,ub=100))
model.TiTm_2c$setParameter( Ria = c(init=20  ,lb=1     ,ub=1E5))
model.TiTm_2c$setParameter( Rim = c(init=1   ,lb=1E-4  ,ub=100))
model.TiTm_2c$setParameter( p11 = c(init=1   ,lb=-30   ,ub=10) )
model.TiTm_2c$setParameter( p22 = c(init=1   ,lb=-30   ,ub=10) )
model.TiTm_2c$setParameter( e11 = c(init=-1  ,lb=-50   ,ub=10) )
model.TiTm_2c$setParameter( p = c(init=0.5  ,lb=0   ,ub=1) )
model.TiTm_2c$setParameter( Aw = 7.5+4.8 )

## Run the parameter optimization
fit.TiTm_2c <- model.TiTm_2c$estimate(data)
```


```{r}
analyzeFit(fit.TiTm_2c, plotit = FALSE)
prm$fit.TiTm_2c$Ci <- data.frame(summary(fit.TiTm_2c)$coefficients)["Ci","Estimate"]
prm$fit.TiTm_2c$Cm <- data.frame(summary(fit.TiTm_2c)$coefficients)["Cm","Estimate"]
prm$fit.TiTm_2c$loglik <- fit.TiTm_2c$loglik
```

#### Findings
\begin{itemize}
\item Log like
\begin{itemize}
\item Question 2b: `r prm$fit.TiTm_2b$loglik`
\item Question 2c: `r prm$fit.TiTm_2c$loglik`
\end{itemize}
\item Cap
\begin{itemize}
\item $C_i + C_m$
\item Question 2b: `r prm$fit.TiTm_2b$Cm + prm$fit.TiTm_2b$Ci`
\item Question 2c: `r prm$fit.TiTm_2c$Cm + prm$fit.TiTm_2c$Ci`
\end{itemize}
\end{itemize}




### Question 2d
Not considered due to time.